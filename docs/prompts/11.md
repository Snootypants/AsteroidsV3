# Playability QA Findings – Actionable Fixes

Context: Current build shows UI but gameplay is not reliably playable. Specific issues observed:
- Start screen lacks visible buttons; interactions are unclear.
- Ship doesn’t consistently follow mouse pointer (aim/rotation).
- Shooting doesn’t trigger.
- No visible asteroids after starting.
- Minimap doesn’t reflect world state.
- Visible area (camera) doesn’t follow player across the larger map.
- Unsure if world wrapping works for player/bullets/asteroids.

Goal for CC: Implement small, targeted changes so a new player can start, aim with mouse, shoot, see asteroids, and have the camera/minimap reflect action immediately.

## Changes To Implement (precise, low‑risk)

1) Start Screen – Real Buttons + Clear UX
- File: `src/framework/components/overlays/StartScreen.tsx`
- Replace click‑anywhere with visible buttons: “Start Game”, “Settings”, “How to Play”.
- Keep overlay keyboard shortcuts (Space/Enter), but ensure buttons are accessible and obvious.
- Implementation:
  - Add a centered button group; wire Start to `onStartGame`.
  - Ensure overlay container has `pointerEvents: 'auto'` so clicks work consistently.
- Acceptance: Buttons are visible and clickable; Space/Enter still start.

2) Mouse Aiming – Rotate Ship Toward Pointer
- File: `src/framework/game/Game.tsx`
- In `updateShipControls`, add mouse‑based rotation mirroring the logic in `EntitySystemTest.tsx`.
- Implementation details:
  - Use existing `mousePos` and `threeScene.mountRef` + `sceneRefs.camera`.
  - Convert screen → world:
```
const rect = threeScene.mountRef.current!.getBoundingClientRect();
const normalizedX = (mousePos.current.x / rect.width) * 2 - 1;
const normalizedY = -((mousePos.current.y / rect.height) * 2 - 1);
const cam = threeScene.sceneRefs.current!.camera;
const worldX = normalizedX * (cam.right - cam.left) / 2 + cam.position.x;
const worldY = normalizedY * (cam.top - cam.bottom) / 2 + cam.position.y;
const dx = worldX - ship.position.x;
const dy = worldY - ship.position.y;
ship.setTargetRotation(Math.atan2(dx, dy));
```
- Preserve keyboard rotation (A/D) as an override if pressed; otherwise prefer mouse aim.
- Acceptance: Ship nose tracks mouse smoothly; no jitter when camera moves.

3) Shooting – Ensure Space Works + Autofire Option
- File: `src/framework/game/Game.tsx`
- Key handling: prevent default for Space on keydown to avoid browser conflicts.
- In `handleShooting`, log when a bullet is spawned; ensure `entityManager.addExistingEntity` + `bullet.spawn(scene)` executes.
- Optional: Expose a temporary toggle to set `autofire=true` in `GameSettings` during testing.
- Acceptance: Pressing Space fires reliably; muzzle flash/sparks visible; no console errors.

4) Spawn Asteroids on Wave Start
- Files: `src/framework/game/Game.tsx`, `src/framework/systems/WaveSystem.ts`
- After systems initialize, ensure `waveSystem.startWave()` is called from `handleStartGame` (already present) and that it runs only once per start.
- Verify asteroids appear: if not, add logging inside `WaveSystem.spawnWave` to confirm `spawnAsteroid` calls.
- Acceptance: Starting the game immediately shows several drifting asteroids.

5) Camera Follow – Track Player Across World
- File: `src/framework/game/Game.tsx`
- After spawning ship, call `threeScene.setCameraFollow(newShip.mesh!)`.
- In the RAF loop, the scene already updates; following keeps ship centered and makes large‑map traversal visible.
- Acceptance: Camera tracks ship smoothly; world appears to move as player moves.

6) Minimap – Render Live Entities
- File: `src/framework/components/hud/Minimap.tsx`
- Hook up to `EntityManager` or expose a simple entity list provider.
- Minimal implementation:
  - Ship: draw a bright triangle/dot at `ship.position`.
  - Asteroids: draw small gray dots; bullets: tiny yellow dots.
  - Map transform: `mx = ((x / (WORLD.width/2)) * 0.5 + 0.5) * width` (same for y), with y flipped for screen coords.
- If accessing `EntityManager` directly from HUD is not desired, add a lightweight context or props passing from `Game.tsx`.
- Acceptance: Minimap shows ship and asteroids in correct relative positions updating every frame.

7) World Wrapping – Verify and Visualize
- Files: `src/framework/entities/BaseEntity.ts`, `src/framework/systems/PhysicsSystem.ts`
- Wrapping logic exists; add a temporary debug log when a wrap occurs (only once per entity type per few seconds) to confirm it’s working.
- Ensure bullets also wrap or intentionally despawn at bounds based on design (currently bullets despawn by lifetime; that’s fine).
- Acceptance: Player/asteroids traverse edges seamlessly; bullets behave per spec; minimap positions wrap correctly.

## Implementation Plan for CC
1. Start Screen: Add visible buttons and hook up handlers.
2. Game.tsx: Mouse aiming and Space preventDefault; bullet spawn logging.
3. Game.tsx: After ship spawn, call `setCameraFollow`; keep RAF rendering background.
4. WaveSystem: Add logs in `spawnWave`; confirm asteroids appear; fix if missed.
5. Minimap: Wire entity positions; render ship/asteroids/bullets minimally.
6. Optional: Temporary autofire toggle in settings to aid testing.
7. Remove or gate debug logs after verification.

## Validation Checklist
- Start screen shows Start button; clicking it transitions to gameplay.
- Ship tracks mouse; A/D still rotates when held.
- Space fires bullets; effects show; no errors.
- Asteroids visibly spawn on first wave.
- Camera follows ship; world wraps seamlessly.
- Minimap updates to show ship/asteroids/bullets with correct relative layout.
- No regression in Entity System Test or UI Integration Test.

Please show diffs for the files above, apply, and provide a quick manual test script output.

