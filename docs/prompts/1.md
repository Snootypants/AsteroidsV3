This plan looks solid and actionable. A few adjustments:

Three.js dependencies: Stick with vanilla Three.js instead of @react-three/fiber and @react-three/postprocessing. The vanilla implementation uses direct Three.js APIs for precise control over rendering pipeline, camera behavior, and postprocessing effects. React Three Fiber might introduce abstractions that make it harder to match the exact vanilla behavior.
Entity definitions: Move the entity creation functions (Ship.ts, Asteroid.ts, Bullet.ts, Enemy.ts) from /game/entities/ to /framework/entities/ since these are reusable patterns that other arcade games would need.
Constants organization: The /framework/constants/ should include the exact values from the vanilla implementation - the WORLD, PLAYER, ASTEROIDS, BULLET, ENEMY constants that are currently hardcoded.

Proceed with Phase 1. Start with the project setup and useGameState hook. Make sure the GameState interface matches exactly what's in the vanilla main.js - all those currency variables, mod properties, timers, etc.