# Asteroids+ – Targeted Patch List (Lean Edits For CC)

Purpose: Minimize back‑and‑forth by giving exact edit points (file:line) and drop‑in code blocks. Implement in order. Show unified diffs before applying. Commit and push at the end.

Note on line numbers: Provided from current repo snapshot. If they drift, search by the nearby function signature and anchor comments.

---

## 1) Asteroid Kills Should Drop Currency

- File: src/framework/systems/CollisionSystem.ts:378
- Function: handleBulletAsteroidCollision(...)
- After debris/VFX at the end of the method (around vfxManager?.shakeScreen(shakePreset);), spawn currency pickups.

Drop‑in (append before method return):
```ts
// Currency drops (weighted). Uses existing spawn helpers and magnet targeting.
try {
  const ships = entityManager.getActiveEntities('ships') as Ship[];
  const dropCount = Math.random() < 0.7 ? 1 : 2; // 70% one, 30% two
  for (let i = 0; i < dropCount; i++) {
    const p = entityManager.spawnRandomPickup(position.x, position.y);
    if (ships.length) p.setMagnetTarget(ships[0]);
  }
} catch (e) {
  console.warn('[CollisionSystem] Pickup spawn failed:', e);
}
```

---

## 2) Fix Unknown SFX/VFX IDs For Pickups

- File: src/framework/systems/CollisionSystem.ts:596
- Function: handleShipPickupCollision(...)
- Current cases reference undefined presets: pickup.coin, pickup.rare, pickup_yellow, pickup_white, pickup_purple.

Replace the switch body with:
```ts
switch (pickupType) {
  case 'salvage':
  case 'gold':
  case 'platinum':
  case 'adamantium':
    audioManager?.playSound('pickup.salvage');
    vfxManager?.flash('pickup_green');
    break;
  case 'health':
  case 'shield':
    audioManager?.playSound('pickup.health');
    vfxManager?.flash('pickup_green');
    break;
  case 'rapidfire':
  case 'pierce':
  case 'damage':
    audioManager?.playSound('pickup.powerup');
    vfxManager?.flash('powerup_blue');
    vfxManager?.shakeScreen('pickup_collect');
    break;
}
```

---

## 3) Left‑Click Shooting

- File: src/framework/game/Game.tsx (Input handlers useEffect near other key listeners)

Add mouse listeners and include mouse state in handleShooting:
```ts
useEffect(() => {
  const onMouseDown = (e: MouseEvent) => {
    if (currentState !== 'playing') return;
    if ((e.target as HTMLElement)?.closest('[data-overlay]')) return;
    mousePressed.current.add(e.button);
    if (e.button === 0) e.preventDefault();
  };
  const onMouseUp = (e: MouseEvent) => { mousePressed.current.delete(e.button); };
  window.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mouseup', onMouseUp);
  return () => {
    window.removeEventListener('mousedown', onMouseDown);
    window.removeEventListener('mouseup', onMouseUp);
  };
}, [currentState]);

// In handleShooting:
const isShooting = gameSettings.autofire ||
                  keysPressed.current.has(gameSettings.controls.shoot) ||
                  mousePressed.current.has(0);
```

---

## 4) Bullet Range = 1.5× Visible Height (Derived)

- File: src/framework/entities/Bullet.ts:110
- Import VISIBLE_HEIGHT and compute lifetime dynamically to avoid constant dependency cycles.

Add at top:
```ts
import { BULLET, VISIBLE_HEIGHT } from '../constants/gameConstants';
```

Then in onSpawn() and onReset():
```ts
this.lifetime = (VISIBLE_HEIGHT * 1.5) / BULLET.speed;
```

---

## 5) Off‑Map Asteroid Spawning With Inbound Velocity

- File: src/framework/systems/WaveSystem.ts:520 (function getSpawnPosition)

Replace function body with:
```ts
private getSpawnPosition(): { x: number; y: number } {
  const margin = 20;
  const halfW = WORLD.width / 2;
  const halfH = WORLD.height / 2;
  const side = Math.floor(Math.random() * 4); // 0:L,1:R,2:T,3:B
  switch (side) {
    case 0: return { x: -halfW - margin, y: (Math.random() * 2 - 1) * halfH };
    case 1: return { x:  halfW + margin, y: (Math.random() * 2 - 1) * halfH };
    case 2: return { x: (Math.random() * 2 - 1) * halfW, y:  halfH + margin };
    default:return { x: (Math.random() * 2 - 1) * halfW, y: -halfH - margin };
  }
}
```

- In spawnWave(...), set inward velocity before spawning each asteroid:
```ts
const toCenter = new THREE.Vector3(-position.x, -position.y, 0).normalize();
const tangent  = new THREE.Vector3(-toCenter.y, toCenter.x, 0);
const base = ASTEROIDS.baseSpeed * config.speedMultiplier;
const speed = base * (0.8 + Math.random() * 0.4);
const tangentAmt = (Math.random() - 0.5) * 0.5 * base;
const velocity = new THREE.Vector3(
  toCenter.x * speed + tangent.x * tangentAmt,
  toCenter.y * speed + tangent.y * tangentAmt,
  0
);
```
Use velocity in the spawn call.

---

## 6) Hangar Every Other Wave (Cadence)

- File: src/framework/game/Game.tsx:98 (systems init effect)

Register wave callbacks to open hangar on even waves:
```ts
ws.onWaveCompleteCallback((wave, _perfect) => {
  if (wave % 2 === 0) {
    gameStateManager.setState('paused');
    // Render Hangar overlay via overlay manager/state
  } else {
    setTimeout(() => ws.startWave(), 1500);
  }
});
```

---

## 7) Hangar Background Path Fix

- File: src/framework/components/overlays/HangarScreen.tsx:80

Replace with ESM URL:
```tsx
<img
  className="overlay-img"
  src={new URL('../../../assets/Hanger.png', import.meta.url).toString()}
  alt="Hangar background"
  loading="eager"
/>
```

---

## 8) Minimap — Full WORLD + Viewport Rectangle + Tab Toggle

- File: src/framework/game/Game.tsx — compute viewport and pass to HUD/Minimap.

Add:
```ts
const refs = threeScene.sceneRefs.current;
const viewport = refs ? {
  cx: refs.camera.position.x,
  cy: refs.camera.position.y,
  camW: refs.camera.right - refs.camera.left,
  camH: refs.camera.top - refs.camera.bottom,
} : undefined;
```
Pass { entityManager, viewport, minimapOpacity } into HUD → Minimap.

- File: src/framework/components/hud/Minimap.tsx

Use transform and draw rectangle:
```ts
const toMini = (x: number, y: number) => {
  const nx = (x + WORLD.width/2) / WORLD.width;
  const ny = 1 - (y + WORLD.height/2) / WORLD.height;
  return { x: nx * width, y: ny * height };
};
// Draw viewport rectangle from (cx, cy, camW, camH)
```

- Tab toggle in Game.tsx keydown:
```ts
if (e.code === 'Tab' && currentState !== 'menu') {
  const target = e.target as HTMLElement;
  if (!target || !(/input|textarea|select/i.test(target.tagName) || target.isContentEditable)) {
    e.preventDefault();
    setMinimapOpacity(v => (v < 0.5 ? 1.0 : 0.1));
  }
}
```

---

## 9) Reverse Thrust Support (Ship)

- File: src/framework/entities/Ship.ts

Add flag and method:
```ts
private thrustingReverse = false;
public setReverseThrusting(on: boolean) { this.thrustingReverse = on; }
```
Apply in thrust logic:
```ts
if (this.thrusting || this.thrustingReverse) {
  const mult = this.thrusting ? 1.0 : 0.65;
  const thrustX = Math.sin(this.rotation) * PLAYER.accel * mult * dt;
  const thrustY = Math.cos(this.rotation) * PLAYER.accel * mult * dt;
  this.velocity.x += thrustX;
  this.velocity.y += thrustY;
}
```
In Game.tsx controls: W → setThrusting(true); S → setReverseThrusting(true); clear on keyup.

---

## 10) Scoring On Asteroid Kill

- File: src/framework/game/Game.tsx:86

Register a scoring hook:
```ts
cs.onCollision('bullet-asteroid', () => {
  scoringSystem?.addScore(ScoringSystem.getAsteroidPoints('small')); // size-aware later
  scoringSystem?.updateCombo(1);
});
```

---

## 11) Optional – Centralize Pickup Weights

- File: src/framework/entities/Pickup.ts:400 (createRandom)

Replace weights with a single distribution constant or import from game constants to match balance.

---

## Commit & Push

```bash
git add -A
git commit -m "feat(game): asteroid drops + pickup FX fix + left-click shoot + bullet range derive + off-map spawns + hangar cadence + minimap viewport + reverse thrust + scoring hook"
git push
```

---

## Reviewer Notes & Corrections (quick adjustments before CC applies)

These address edge cases caught during review. CC should incorporate them while implementing the relevant sections above.

1) Reverse thrust sign
- Replace the reverse‑thrust code in Ship with a signed multiplier (backwards at 65% power):
```ts
// In Ship thrust application
if (this.thrusting || this.thrustingReverse) {
  const dir = this.thrusting ? 1.0 : -0.65; // reverse uses opposite sign
  const thrustX = Math.sin(this.rotation) * PLAYER.accel * dir * dt;
  const thrustY = Math.cos(this.rotation) * PLAYER.accel * dir * dt;
  this.velocity.x += thrustX;
  this.velocity.y += thrustY;
}
```

2) Mouse listeners should be non‑passive
- Use non‑passive listeners so `preventDefault()` suppresses selection/back gestures:
```ts
window.addEventListener('mousedown', onMouseDown, { passive: false });
window.addEventListener('mouseup', onMouseUp, { passive: false });
```

3) Bullet lifetime derivation and constant cycles
- Prefer `this.lifetime = (VISIBLE_HEIGHT * 1.5) / BULLET.speed;`
- If importing constants causes a cycle, compute lifetime from a value passed in at construction or set by the caller based on the orthographic camera’s frustum.

4) WaveSystem imports and camera assumption
- Ensure `import * as THREE from 'three';` and `import { WORLD, ASTEROIDS } from '../constants/gameConstants';`
- The minimap/viewport logic assumes OrthographicCamera (left/right/top/bottom). If perspective is ever used, compute visible W/H from camera and z instead.

5) Currency drop API existence
- This plan uses `entityManager.spawnRandomPickup(x,y)` and `pickup.setMagnetTarget(ship)`. Both exist in this repo. If APIs drift, switch to the actually available factory/target methods.

6) SFX/VFX identifier sanity
- AudioManager expected keys: `pickup.salvage`, `pickup.health`, `pickup.powerup`.
- VFXManager expected presets: `pickup_green`, `powerup_blue`, and a shake preset `pickup_collect`.
- If names differ (casing/underscores), adjust to match the registries to avoid silent no‑ops.

7) Hangar asset spelling
- The repo contains `Hanger.png`. Use that exact filename (or rename the asset and references consistently) when building the ESM URL.

8) Wave cadence callback registration
- Guard against double registration if systems re‑init:
```ts
let waveCallbacksRegistered = false;
if (!waveCallbacksRegistered) {
  waveCallbacksRegistered = true;
  ws.onWaveCompleteCallback(/* ... */);
}
```

9) Scoring with asteroid size
- Use the collision event’s entityB (asteroid) radius to choose `large|medium|small` for `ScoringSystem.getAsteroidPoints(size)` instead of hardcoding.

10) Minimap viewport robustness
- Null‑check `sceneRefs.current` and memoize computed viewport. If camera zoom changes, left/right/top/bottom already reflect it after `updateProjectionMatrix()`.

11) Shooting cooldown
- Ensure `handleShooting` still respects weapon cooldown (e.g., `ship.canShoot()`) so holding mouse doesn’t bypass the fire rate.
